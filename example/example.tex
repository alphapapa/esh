%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%       This file shows how to use and customize esh2tex.       %
% (Comments marked with a '*' indicate optional customizations) %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\documentclass{article}

%%%%%%%%%%%%%%%%%%%%%%%
% Load a few packages %
%%%%%%%%%%%%%%%%%%%%%%%

\usepackage[margin=0.85in]{geometry}

%%%%%%%%%%%%%%%%%%%%%%
% *Load custom fonts %
%%%%%%%%%%%%%%%%%%%%%%

\usepackage{fontspec}

% Load XITS Math (monospacified) for symbols
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% https://github.com/cpitclaudel/monospacifier
\newfontfamily{\XITSMath}[Path=fonts/,
                          UprightFont=*_monospacified_for_UbuntuMono.ttf,
                          BoldFont=*-Bold_monospacified_for_UbuntuMono.ttf,
                          Mapping=tex-ansi]{XITSMath}

% Load Ubuntu Mono for code
%%%%%%%%%%%%%%%%%%%%%%%%%%%

% http://font.ubuntu.com/
\newfontfamily{\UbuntuMono}[Path=fonts/,
                            UprightFont=*-R.ttf,
                            BoldFont=*-B.ttf,
                            ItalicFont=*-RI.ttf,
                            BoldItalicFont=*-BI.ttf,
                            Mapping=tex-ansi]{UbuntuMono}

% Tell ESH about these fonts
%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newcommand{\ESHFont}{\UbuntuMono}
\newcommand{\ESHInlineFont}{\UbuntuMono}
\newcommand{\ESHSpecialCharFont}{\XITSMath}

%%%%%%%%%%%%%%%%%%%%%%
% *Customize spacing %
%%%%%%%%%%%%%%%%%%%%%%

\newlength{\ESHSkip}
\setlength{\ESHSkip}{1.25\baselineskip}

%%%%%%%%%%%%%%%%%%%%%%%%%%%
% *Customize environments %
%%%%%%%%%%%%%%%%%%%%%%%%%%%

% \ESHInline
%%%%%%%%%%%%

% Note the extra pair of braces in the definition, which prevent fonts and
% settings from affecting subsequent text
\usepackage{amsmath,amssymb}
\newcommand*{\ESHInline}[1]{{\ESHInlineBasicSetup$\langle\,$#1$\,\rangle$}}

% \ESHBlock
%%%%%%%%%%%

\newenvironment{ESHBlock}{%
  \ESHBlockBasicSetup\par\addvspace{\ESHSkip}\hrule\addvspace{0.5em}%
}{%
  \par\addvspace{0.5em}\hrule\addvspace{\ESHSkip}
}

%%%%%%%%%%%%%%%%%%%%%%%%%
% Load the ESH preamble %
%%%%%%%%%%%%%%%%%%%%%%%%%

%% ESH-preamble-here

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Define and register a few inline environments %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\def\cverb{\verb}
\def\javaverb{\verb}
\def\pythonverb{\verb}
\def\prettylisp{\verb}
\def\normallisp{\verb}

%% ESH-inline: c-mode \cverb|...|
%% ESH-inline: java-mode \javaverb|...|
%% ESH-inline: python-mode \pythonverb|...|
%% ESH-inline: emacs-lisp-mode \normallisp|...|
%% ESH-inline: prettified-emacs-lisp-mode \prettylisp|...|

\begin{document}

\section*{C (source: \texttt{xfaces.c} in Emacs)}

%% ESH: c-mode
\begin{verbatim}
#if defined HAVE_X_WINDOWS && defined USE_X_TOOLKIT

/* Make menus on frame F appear as specified by the `menu' face.  */

static void
x_update_menu_appearance (struct frame *f)
{
  struct x_display_info *dpyinfo = FRAME_DISPLAY_INFO (f);
  XrmDatabase rdb;

  if (dpyinfo
      && (rdb = XrmGetDatabase (FRAME_X_DISPLAY (f)),
      rdb != NULL))
    {
      char line[512];
      char *buf = line;
      ptrdiff_t bufsize = sizeof line;
      Lisp_Object lface = lface_from_face_name (f, Qmenu, true);
      struct face *face = FACE_FROM_ID (f, MENU_FACE_ID);
      const char *myname = SSDATA (Vx_resource_name);
      bool changed_p = false;
#ifdef USE_MOTIF
      const char *popup_path = "popup_menu";
#else
      const char *popup_path = "menu.popup";
#endif

      if (STRINGP (LFACE_FOREGROUND (lface)))
\end{verbatim}

\section*{Emacs lisp (source: \texttt{esh.el} in this library)}

%% ESH: emacs-lisp-mode
\begin{verbatim}
(require 'seq)
(require 'color)
(require 'subr-x)

;;; Misc utils

(defun esh--normalize-color (color)
  "Return COLOR as a hex string."
  (upcase (if (= (aref color 0) ?#) color
            (apply #'color-rgb-to-hex (color-name-to-rgb color)))))

(defun esh--filter-cdr (val alist)
  "Remove conses in ALIST whose `cdr' is VAL."
  (seq-filter (lambda (pair) (not (eq (cdr pair) val))) alist))

(defun esh--extract-props (props str)
  "Read PROPS from STR as an ALIST or (PROP . VAL)."
  (seq-map (lambda (prop)
             (cons prop (get-text-property 0 prop str)))
           props))
\end{verbatim}

\clearpage

\section*{Python (source: \texttt{monospacifier.py})}

%% ESH: python-mode
\begin{verbatim}
class GlyphScaler(object):
    def __init__(self, cell_width):
        self.cell_width = cell_width

    @staticmethod
    def set_width(glyph, width):
        delta = width - glyph.width
        glyph.left_side_bearing += delta / 2
        glyph.right_side_bearing += delta - glyph.left_side_bearing
        glyph.width = width

class AllowWideCharsGlyphScaler(GlyphScaler):
    def __init__(self, cell_width, avg_width):
        """Construct instance based on target CELL_WIDTH and source AVG_WIDTH."""
        GlyphScaler.__init__(self, cell_width)
        self.avg_width = avg_width

    def scale(self, glyph):
        if glyph.width > 0:
            new_width_in_cells = int(math.ceil(0.75 * glyph.width / self.avg_width))
            # if new_width_in_cells > 1:
            #     print("{} is {} cells wide ({} -> {})".format(
            #         glyph.glyphname, new_width_in_cells, self.cell_width, glyph.width))
            GlyphScaler.set_width(glyph, new_width_in_cells * self.cell_width)
\end{verbatim}

\section*{Perl (source: YAGOpt)}

%% ESH: perl-mode
\begin{verbatim}
#Yet Another Getopt Routine In Perl
# jgreely@cis.ohio-state.edu, 89/11/1
#usage:
#&getopt("f:bar") ||
#	die &usage("script","f:bar","oo","[files ...]");

sub getopt {
    local($_,$flag,$opt,$f,$r,@temp) = @_;
    @temp = split(/(.):/);
    while ($#temp >= $[) {
        $flag .= shift(@temp);
        $opt .= shift(@temp);
    }
    while ($_ = $ARGV[0], /^-(.)(.*)/ && shift(@ARGV)) {
        ($f,$r) = ($1,$2);
        last if $f eq '-';
        if (index($flag,$f) >= $[) {
            eval "\$opt_$f++;";
            $r =~ /^(.)(.*)/,redo if $r ne '';
        } elsif (index($opt,$f) >= $[) {
            $r = $r eq '' ? shift(@ARGV) : $r;
            eval "\$opt_$f = \$r;";
        } else {
\end{verbatim}

\clearpage

\section*{Misc}

\subsection*{Inline snippets}

ESH works inline as well:

\begin{itemize}
\item Here's some C code: \cverb|int main() { return 0; }|
\item Some Python: \pythonverb|def method(self, x): yield x|
\item
  \begin{tabular}[t]{@{}r@{ }l}
    Some Elisp with prettification: & \prettylisp|(lambda (x y) (or (<= x y) (approx= (/+/ x y) 0)))| \\
            without prettification: & \normallisp|(lambda (x y) (or (<= x y) (approx= (/+/ x y) 0)))| \\
  \end{tabular}
\end{itemize}

\subsection*{Line breaking}

ESH allows line breaks to happen within inline code snippets (here is an example: \javaverb|private static volatile int counter = 0|), but not in code blocks:

%% ESH: emacs-lisp-mode
\begin{verbatim}
(defun esh--normalize-color (color) (upcase (if (= (aref color 0) ?#) color (apply #'color-rgb-to-hex (color-name-to-rgb color)))))
\end{verbatim}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% The following requires additional packages %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section*{Highlighting with non-core Emacs packages}

The following examples all depend on externally developped packages, and thus
require that you run \texttt{cask install} to install these dependencies (Cask
is the Emacs Lisp equivalent of Python's virtualenvs).

\subsection*{Haskell (source: \texttt{Monoid.hs} in Haskell's standard library)}

%% ESH: haskell-mode
\begin{verbatim}
-- | The dual of a 'Monoid', obtained by swapping the arguments of 'mappend'.
newtype Dual a = Dual { getDual :: a }
        deriving (Eq, Ord, Read, Show, Bounded, Generic, Generic1)

instance Monoid a => Monoid (Dual a) where
        mempty = Dual mempty
        Dual x `mappend` Dual y = Dual (y `mappend` x)

instance Functor Dual where
    fmap     = coerce

instance Applicative Dual where
    pure     = Dual
    (<*>)    = coerce

instance Monad Dual where
    m >>= k  = k (getDual m)

-- | The monoid of endomorphisms under composition.
newtype Endo a = Endo { appEndo :: a -> a }
               deriving (Generic)

instance Monoid (Endo a) where
        mempty = Endo id
        Endo f `mappend` Endo g = Endo (f . g)
\end{verbatim}

\clearpage

\subsection*{Racket (source: \texttt{misc.rkt} in Racket's standard library)}

%% ESH: racket-mode
\begin{verbatim}
  (define-syntax define-syntax-rule
    (lambda (stx)
      (let-values ([(err) (lambda (what . xs)
                            (apply raise-syntax-error
                                   'define-syntax-rule what stx xs))])
        (syntax-case stx ()
          [(dr (name . pattern) template)
           (identifier? #'name)
           (syntax/loc stx
             (define-syntax name
               (lambda (user-stx)
                 (syntax-case** dr #t user-stx () free-identifier=? #f
                   [(_ . pattern) (syntax-protect (syntax/loc user-stx template))]
                   [_ (pattern-failure user-stx 'pattern)]))))]
          [(_ (name . ptrn) tmpl)         (err "expected an identifier" #'name)]
\end{verbatim}

\subsection*{Dafny (source: \texttt{DutchFlag.dfy} in Dafny's repo)}

%% ESH: dafny-mode
\begin{verbatim}
method DutchFlag(a: array<Color>)
  requires a != null modifies a
  ensures forall i,j :: 0 <= i < j < a.Length  ==>  Ordered(a[i], a[j])
  ensures multiset(a[..]) == old(multiset(a[..]))
{
  var r, w, b := 0, 0, a.Length;
  while w != b
    invariant 0 <= r <= w <= b <= a.Length;
    invariant forall i :: 0 <= i < r ==> a[i] == Red
    invariant multiset(a[..]) == old(multiset(a[..]))
  {   match a[w]
        case Red =>
          a[r], a[w] := a[w], a[r];
          r, w := r + 1, w + 1;
\end{verbatim}

\subsection*{Coq (source: \texttt{Between.v} in Coq's standard library)}

%% ESH: prettified-coq-mode
\begin{verbatim}
Implicit Types k l p q r : nat.

Section Between.
  Variables P Q : nat -> Prop.

  Inductive between k : nat -> Prop :=
    | bet_emp : between k k
    | bet_S : forall l, between k l -> P l -> between k (S l).

  Hint Constructors between: arith v62.

  Lemma bet_eq : forall k1 k2, k1 = k2 -> between k1 k2.
  Proof.
    induction 1; auto with arith.
  Qed.
\end{verbatim}

\clearpage

\end{document}